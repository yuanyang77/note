#!/usr/bin/env python
#!--*-- coding: utf-8 --*--
# Author yancy


# 生成器，只有在调用时才会生成相应的数据
# 只记录当前的位置
# 只有一个__net__() 方法。
x = ( i*i for i in range(10))
print(x)


# 通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的，而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面的几个元素，那后面绝大多数元素占用的空间就白白浪费了。所以，如果列表元素可以按照某种算法推算出来，那我们是可以在循环中的过程中不断的推算出后续的元素呢？这样就不必创建完整的list，从而节省了大量的空间。在python中，这种一边循环一边计算的机制，称为生成器：generator.
# 　　生成器特点：
# 　　　　　　　　1.只有在调用的时候才会生成相应的数据，这是节省内存的核心因素；
# 　　　　　　　　2.只记录当前位置；
# 　　　　　　　　3.只有一个__next___()方法。 在python2.7中使用next方法则用：next().

# 栗子1：一个简单的生成器
# 列表生成式，使代码更简单
# fist = [ i*2 for i in range(10)]
# print(fist)
#
# for i in range(10,20):      #查看这个生成器的所有元素
#     print(i)
#
# print(fist.__next__())      #打印第生成器的第一个数据
# print(fist.__next__())      #打印生成器的第二个数据，并且会自动从内存中删除上一个数据所占的内存
# print(fist.__next__())      #打印生成器的第三个数据，并且会自动从内存中删除之前所占的内存变量，也就是只保存当前的数据，不过__next__方法我们用的很少，一般都是用for循环实现，以减少代码的重复
#
# list_0 = [ i*2 for i in range(20)]  #这种方法是列表生成生成式，和下面(list_1)的3行代码的效率是一样的，但是代码更加简洁。
# list_1 = []
# for i in range(20):
#     list_1.append(1*2)
# print(list_0)
# print(list_1)
# # 如果上面要循环1万次，会对内存占用很大的空间，而且还会浪费时间！python解释器有一个神器出现了，就是生成器，它生成的是一个内存地址，并没有真正的开辟内存空间！只有通过__next__方法（一般用循环）取值的时候才会去得到相应的数字。
#
# list_3 = (i*2 for i in range(1000000))      #这定义一个生成器，如果用列表定义的话可能要等待3s左右，但是生成器则是你定义完毕就OK了，随时可以调用
# print(list_3)       #仅是生成了一个生成器的内存地址

# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


# 栗子2：用生成器写斐波那契数列
# def fib(max):
#     n,a,b = 0,0,1
#     while n < max:
#         print(b)
#         yield  b    #如果一个函数中有yield的存在就不能叫只叫它函数了，而是一个生成器
#         a,b = b,a+b #相当于：t = (b,a + b) ; a =t[0] ;b =t[1]
#         n = n+1
#         return 'done'
# f = fib(100)
# print(f)
# for i in range(10):
#     print(f.__next__())
#
# g = fib(6)
# while True:
#     try:
#         x = next(g)
#         print('g:',x)
#     except StopIteration as e:
#         print("Generator return value:",e,value)
#         break

# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# 栗子3：生成器的send方法
import time
def consumer(name):
    print("%s 准备吃包子啦!" %name)
    while True:
       baozi = yield

       print("包子[%s]来了,被[%s]吃了!" %(baozi,name))

c = consumer("ChenRonghua")
c.__next__()

# b1= "韭菜馅"
# c.send(b1)
# c.__next__()

def producer(name):
    c = consumer('A')
    c2 = consumer('B')
    c.__next__()
    c2.__next__()
    print("开始准备做包子啦!")
    for i in range(10):
        time.sleep(1)
        print("做了1个包子,分两半!")
        c.send(i)
        c2.send(i)

producer("yy")